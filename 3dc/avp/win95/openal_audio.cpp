
#ifdef USE_OPENAL

#include "console.h"
#include "logString.h"
#include "configFile.h"
#include "audioStreaming.h"
#include "io.h"
#include "3dc.h"
#include "inline.h"
#include <assert.h>
#include "module.h"
#include "stratdef.h"
#include "gamedef.h"
#include "dynamics.h"
#include "psndplat.h"
#define UseLocalAssert TRUE
#include "ourasert.h"
#include "db.h"
#include <math.h>
#include <new>
#include "FileStream.h"
#include <AL\al.h>
#include <AL\alc.h>
#include <AL\alext.h>
#include <AL\efx-presets.h>

// make common
struct SoundConfigTag
{
	bool		reverb_changed;
	float		reverb_mix;
	uint32_t	env_index;
};

SOUNDSAMPLEDATA GameSounds[SID_MAXIMUM];
ACTIVESOUNDSAMPLE ActiveSounds[SOUND_MAXACTIVE];
SOUNDSAMPLEDATA BlankGameSound;
ACTIVESOUNDSAMPLE BlankActiveSound;

// put openal globals here
static ALCdevice  *device = 0;
static ALCcontext *context = 0;
//static bool eaxAvailable = false;
static bool efxAvailable = false;

struct ALvector
{
	ALfloat x, y, z;
};

struct AlOrientation
{
	ALvector lookAt;
	ALvector up;
};

std::vector<sndSource> sourceList;

static ALvector playerPosition;
static ALvector playerLookAt;
static AlOrientation playerOrientation;
static ALvector playerVelocity;

static uint32_t	nOutputChannels = 0;
static DWORD	channelMask = 0;
static uint32_t	SoundMinBufferFree = 0;
static bool		soundEnabled = false;

static DWORD kQuantum = 1000 / 60;

// make common
struct SoundConfigTag SoundConfig;
static const int32_t vol_to_atten_table[] = 
{
	-10000, -9922, -8502, -7672, -7083, -6626, -6252, -5936,
	-5663, -5422, -5206, -5011, -4832, -4669, -4517, -4375,
	-4243, -4119, -4002, -3891, -3786, -3686, -3591, -3500,
	-3413, -3329, -3249, -3172, -3097, -3025, -2956, -2889,
	-2824, -2761, -2700, -2640, -2582, -2526, -2472, -2419,
	-2367, -2316, -2267, -2219, -2171, -2125, -2080, -2036,
	-1993, -1951, -1910, -1869, -1829, -1790, -1752, -1714,
	-1678, -1641, -1606, -1571, -1536, -1502, -1469, -1436,
	-1404, -1372, -1341, -1310, -1280, -1250, -1221, -1191,
	-1163, -1135, -1107, -1079, -1052, -1025, -999, -973,
	-947, -922, -896, -872, -847, -823, -799, -775,
	-752, -729, -706, -683, -661, -639, -617, -595,
	-574, -552, -531, -511, -490, -470, -449, -429,
	-410, -390, -371, -351, -332, -314, -295, -276,
	-258, -240, -222, -204, -186, -168, -151, -134,
	-117, -100, -83, -66, -49, -33, -17, 0
};

// bjd - below table taken from openal.c in Linux AvP port by relnev - https://github.com/mbait/avpmp
/* table generated by:
   vol_to_gain_table[volume] = (float) pow(10.0, (double) vol_to_atten_table[volume] / 2000.0);
*/
static const float vol_to_gain_table[] = {
	0.000010f, 0.000011f, 0.000056f, 0.000146f, 0.000287f, 0.000486f, 0.000748f, 0.001076f,
	0.001474f, 0.001945f, 0.002495f, 0.003122f, 0.003837f, 0.004629f, 0.005514f, 0.006494f,
	0.007560f, 0.008720f, 0.009977f, 0.011337f, 0.012794f, 0.014355f, 0.016014f, 0.017783f,
	0.019656f, 0.021652f, 0.023741f, 0.025942f, 0.028281f, 0.030726f, 0.033266f, 0.035934f,
	0.038726f, 0.041639f, 0.044668f, 0.047863f, 0.051168f, 0.054576f, 0.058076f, 0.061731f,
	0.065539f, 0.069502f, 0.073536f, 0.077714f, 0.082130f, 0.086596f, 0.091201f, 0.095940f,
	0.100809f, 0.105803f, 0.110917f, 0.116279f, 0.121759f, 0.127350f, 0.133045f, 0.138995f,
	0.144877f, 0.151182f, 0.157398f, 0.163870f, 0.170608f, 0.177419f, 0.184289f, 0.191426f,
	0.198609f, 0.206063f, 0.213550f, 0.221309f, 0.229087f, 0.237137f, 0.245188f, 0.253805f,
	0.262120f, 0.270707f, 0.279576f, 0.288735f, 0.297852f, 0.307256f, 0.316592f, 0.326212f,
	0.336124f, 0.345939f, 0.356451f, 0.366438f, 0.377138f, 0.387704f, 0.398566f, 0.409732f,
	0.420727f, 0.432016f, 0.443609f, 0.455512f, 0.467197f, 0.479181f, 0.491473f, 0.504081f,
	0.516416f, 0.529663f, 0.542625f, 0.555265f, 0.568853f, 0.582103f, 0.596348f, 0.610239f,
	0.623735f, 0.638263f, 0.652379f, 0.667575f, 0.682339f, 0.696626f, 0.712033f, 0.727780f,
	0.743019f, 0.758578f, 0.774462f, 0.790679f, 0.807235f, 0.824138f, 0.840427f, 0.857038f,
	0.873977f, 0.891251f, 0.908866f, 0.926830f, 0.945148f, 0.962720f, 0.980618f, 1.000000f
};

// this table plots the frequency change for
// 128/ths of a semitone for one octave (0-1535),
// divide or multiply by 2 to subtract or add an octave
static const float pitch_to_frequency_mult_table [] = 
{
	1.0F,			1.00045137F,	1.000902943F,	1.00135472F,	1.001806701F,	1.002258886F,	1.002711275F,	1.003163868F,
	1.003616666F,	1.004069668F,	1.004522874F,	1.004976285F,	1.005429901F,	1.005883722F,	1.006337747F,	1.006791977F,
	1.007246412F,	1.007701053F,	1.008155898F,	1.008610949F,	1.009066205F,	1.009521667F,	1.009977334F,	1.010433207F,
	1.010889286F,	1.011345571F,	1.011802061F,	1.012258758F,	1.012715661F,	1.01317277F,	1.013630085F,	1.014087607F,
	1.014545335F,	1.01500327F,	1.015461411F,	1.01591976F,	1.016378315F,	1.016837077F,	1.017296046F,	1.017755223F,
	1.018214607F,	1.018674198F,	1.019133996F,	1.019594002F,	1.020054216F,	1.020514637F,	1.020975266F,	1.021436104F,
	1.021897149F,	1.022358402F,	1.022819863F,	1.023281533F,	1.023743411F,	1.024205498F,	1.024667793F,	1.025130297F,
	1.025593009F,	1.026055931F,	1.026519061F,	1.026982401F,	1.027445949F,	1.027909707F,	1.028373674F,	1.028837851F,
	1.029302237F,	1.029766832F,	1.030231638F,	1.030696653F,	1.031161878F,	1.031627313F,	1.032092958F,	1.032558813F,
	1.033024879F,	1.033491155F,	1.033957641F,	1.034424338F,	1.034891246F,	1.035358364F,	1.035825694F,	1.036293234F,
	1.036760985F,	1.037228947F,	1.037697121F,	1.038165506F,	1.038634102F,	1.03910291F,	1.039571929F,	1.04004116F,
	1.040510603F,	1.040980258F,	1.041450125F,	1.041920204F,	1.042390495F,	1.042860998F,	1.043331714F,	1.043802642F,
	1.044273782F,	1.044745136F,	1.045216702F,	1.045688481F,	1.046160473F,	1.046632678F,	1.047105096F,	1.047577727F,
	1.048050572F,	1.04852363F,	1.048996902F,	1.049470387F,	1.049944086F,	1.050417999F,	1.050892125F,	1.051366466F,
	1.051841021F,	1.05231579F,	1.052790773F,	1.053265971F,	1.053741383F,	1.05421701F,	1.054692851F,	1.055168907F,
	1.055645178F,	1.056121664F,	1.056598366F,	1.057075282F,	1.057552413F,	1.05802976F,	1.058507323F,	1.058985101F,
	1.059463094F,	1.059941304F,	1.060419729F,	1.06089837F,	1.061377227F,	1.061856301F,	1.06233559F,	1.062815096F,
	1.063294818F,	1.063774757F,	1.064254913F,	1.064735285F,	1.065215874F,	1.06569668F,	1.066177703F,	1.066658943F,
	1.067140401F,	1.067622075F,	1.068103967F,	1.068586077F,	1.069068404F,	1.069550949F,	1.070033712F,	1.070516692F,
	1.070999891F,	1.071483308F,	1.071966943F,	1.072450796F,	1.072934868F,	1.073419158F,	1.073903666F,	1.074388394F,
	1.07487334F,	1.075358505F,	1.075843889F,	1.076329492F,	1.076815315F,	1.077301356F,	1.077787617F,	1.078274098F,
	1.078760798F,	1.079247718F,	1.079734857F,	1.080222216F,	1.080709796F,	1.081197595F,	1.081685615F,	1.082173855F,
	1.082662315F,	1.083150996F,	1.083639897F,	1.084129019F,	1.084618362F,	1.085107926F,	1.085597711F,	1.086087716F,
	1.086577943F,	1.087068391F,	1.087559061F,	1.088049952F,	1.088541065F,	1.089032399F,	1.089523955F,	1.090015733F,
	1.090507733F,	1.090999955F,	1.091492399F,	1.091985065F,	1.092477954F,	1.092971065F,	1.093464399F,	1.093957956F,
	1.094451735F,	1.094945737F,	1.095439962F,	1.09593441F,	1.096429082F,	1.096923976F,	1.097419095F,	1.097914436F,
	1.098410001F,	1.09890579F,	1.099401803F,	1.099898039F,	1.1003945F,		1.100891184F,	1.101388093F,	1.101885226F,
	1.102382583F,	1.102880165F,	1.103377972F,	1.103876003F,	1.104374259F,	1.10487274F,	1.105371446F,	1.105870377F,
	1.106369533F,	1.106868914F,	1.107368521F,	1.107868354F,	1.108368412F,	1.108868695F,	1.109369205F,	1.10986994F,
	1.110370902F,	1.11087209F,	1.111373503F,	1.111875143F,	1.11237701F,	1.112879103F,	1.113381423F,	1.113883969F,
	1.114386743F,	1.114889743F,	1.11539297F,	1.115896424F,	1.116400106F,	1.116904015F,	1.117408152F,	1.117912516F,
	1.118417107F,	1.118921927F,	1.119426974F,	1.119932249F,	1.120437752F,	1.120943484F,	1.121449444F,	1.121955632F,
	1.122462048F,	1.122968693F,	1.123475567F,	1.12398267F,	1.124490002F,	1.124997562F,	1.125505352F,	1.12601337F,
	1.126521619F,	1.127030096F,	1.127538803F,	1.12804774F,	1.128556906F,	1.129066302F,	1.129575929F,	1.130085785F,
	1.130595871F,	1.131106188F,	1.131616734F,	1.132127512F,	1.13263852F,	1.133149758F,	1.133661227F,	1.134172928F,
	1.134684859F,	1.135197021F,	1.135709414F,	1.136222039F,	1.136734895F,	1.137247982F,	1.137761301F,	1.138274852F,
	1.138788635F,	1.139302649F,	1.139816896F,	1.140331374F,	1.140846085F,	1.141361028F,	1.141876204F,	1.142391612F,
	1.142907253F,	1.143423126F,	1.143939233F,	1.144455572F,	1.144972144F,	1.14548895F,	1.146005989F,	1.146523261F,
	1.147040767F,	1.147558506F,	1.148076479F,	1.148594686F,	1.149113126F,	1.149631801F,	1.15015071F,	1.150669853F,
	1.15118923F,	1.151708842F,	1.152228688F,	1.152748769F,	1.153269085F,	1.153789635F,	1.154310421F,	1.154831441F,
	1.155352697F,	1.155874188F,	1.156395914F,	1.156917876F,	1.157440074F,	1.157962507F,	1.158485176F,	1.159008081F,
	1.159531222F,	1.160054599F,	1.160578212F,	1.161102062F,	1.161626148F,	1.16215047F,	1.16267503F,	1.163199826F,
	1.163724859F,	1.164250129F,	1.164775636F,	1.16530138F,	1.165827362F,	1.16635358F,	1.166880037F,	1.167406731F,
	1.167933663F,	1.168460833F,	1.16898824F,	1.169515886F,	1.17004377F,	1.170571892F,	1.171100252F,	1.171628851F,
	1.172157689F,	1.172686765F,	1.17321608F,	1.173745634F,	1.174275427F,	1.174805459F,	1.175335731F,	1.175866241F,
	1.176396992F,	1.176927981F,	1.177459211F,	1.17799068F,	1.178522389F,	1.179054338F,	1.179586527F,	1.180118957F,
	1.180651627F,	1.181184537F,	1.181717688F,	1.182251079F,	1.182784711F,	1.183318584F,	1.183852698F,	1.184387053F,
	1.184921649F,	1.185456487F,	1.185991566F,	1.186526886F,	1.187062448F,	1.187598252F,	1.188134298F,	1.188670585F,
	1.189207115F,	1.189743887F,	1.190280901F,	1.190818158F,	1.191355657F,	1.191893398F,	1.192431383F,	1.19296961F,
	1.19350808F,	1.194046793F,	1.194585749F,	1.195124949F,	1.195664392F,	1.196204079F,	1.196744009F,	1.197284182F,
	1.1978246F,		1.198365262F,	1.198906167F,	1.199447317F,	1.199988711F,	1.200530349F,	1.201072232F,	1.201614359F,
	1.202156731F,	1.202699348F,	1.20324221F,	1.203785317F,	1.204328669F,	1.204872266F,	1.205416109F,	1.205960197F,
	1.206504531F,	1.20704911F,	1.207593935F,	1.208139006F,	1.208684324F,	1.209229887F,	1.209775696F,	1.210321752F,
	1.210868055F,	1.211414604F,	1.211961399F,	1.212508442F,	1.213055731F,	1.213603267F,	1.214151051F,	1.214699082F,
	1.21524736F,	1.215795886F,	1.216344659F,	1.21689368F,	1.217442948F,	1.217992465F,	1.21854223F,	1.219092243F,
	1.219642504F,	1.220193013F,	1.220743771F,	1.221294778F,	1.221846033F,	1.222397537F,	1.22294929F,	1.223501292F,
	1.224053543F,	1.224606044F,	1.225158794F,	1.225711793F,	1.226265042F,	1.226818541F,	1.227372289F,	1.227926288F,
	1.228480536F,	1.229035035F,	1.229589784F,	1.230144783F,	1.230700033F,	1.231255533F,	1.231811285F,	1.232367287F,
	1.23292354F,	1.233480044F,	1.234036799F,	1.234593806F,	1.235151064F,	1.235708573F,	1.236266335F,	1.236824348F,
	1.237382612F,	1.237941129F,	1.238499898F,	1.239058919F,	1.239618193F,	1.240177719F,	1.240737497F,	1.241297528F,
	1.241857812F,	1.242418349F,	1.242979139F,	1.243540182F,	1.244101478F,	1.244663027F,	1.24522483F,	1.245786887F,
	1.246349197F,	1.246911761F,	1.247474579F,	1.248037651F,	1.248600977F,	1.249164558F,	1.249728392F,	1.250292482F,
	1.250856826F,	1.251421424F,	1.251986278F,	1.252551386F,	1.25311675F,	1.253682369F,	1.254248243F,	1.254814372F,
	1.255380757F,	1.255947398F,	1.256514294F,	1.257081446F,	1.257648855F,	1.258216519F,	1.25878444F,	1.259352616F,
	1.25992105F,	1.26048974F,	1.261058687F,	1.26162789F,	1.26219735F,	1.262767068F,	1.263337042F,	1.263907274F,
	1.264477763F,	1.26504851F,	1.265619515F,	1.266190777F,	1.266762297F,	1.267334075F,	1.26790611F,	1.268478405F,
	1.269050957F,	1.269623768F,	1.270196838F,	1.270770166F,	1.271343753F,	1.271917599F,	1.272491703F,	1.273066067F,
	1.273640691F,	1.274215573F,	1.274790715F,	1.275366117F,	1.275941778F,	1.2765177F,		1.277093881F,	1.277670322F,
	1.278247024F,	1.278823985F,	1.279401208F,	1.27997869F,	1.280556434F,	1.281134438F,	1.281712703F,	1.282291229F,
	1.282870016F,	1.283449065F,	1.284028374F,	1.284607946F,	1.285187778F,	1.285767873F,	1.28634823F,	1.286928848F,
	1.287509728F,	1.288090871F,	1.288672276F,	1.289253943F,	1.289835873F,	1.290418066F,	1.291000521F,	1.29158324F,
	1.292166221F,	1.292749466F,	1.293332973F,	1.293916744F,	1.294500779F,	1.295085077F,	1.295669639F,	1.296254465F,
	1.296839555F,	1.297424909F,	1.298010527F,	1.298596409F,	1.299182556F,	1.299768967F,	1.300355643F,	1.300942584F,
	1.30152979F,	1.302117261F,	1.302704997F,	1.303292998F,	1.303881265F,	1.304469797F,	1.305058595F,	1.305647659F,
	1.306236989F,	1.306826584F,	1.307416446F,	1.308006574F,	1.308596968F,	1.309187629F,	1.309778556F,	1.310369751F,
	1.310961212F,	1.311552939F,	1.312144935F,	1.312737197F,	1.313329726F,	1.313922523F,	1.314515588F,	1.31510892F,
	1.31570252F,	1.316296388F,	1.316890524F,	1.317484929F,	1.318079601F,	1.318674542F,	1.319269752F,	1.31986523F,
	1.320460977F,	1.321056993F,	1.321653278F,	1.322249832F,	1.322846655F,	1.323443748F,	1.32404111F,	1.324638742F,
	1.325236643F,	1.325834815F,	1.326433256F,	1.327031968F,	1.327630949F,	1.328230202F,	1.328829724F,	1.329429517F,
	1.330029581F,	1.330629916F,	1.331230522F,	1.331831399F,	1.332432547F,	1.333033967F,	1.333635657F,	1.33423762F,
	1.334839854F,	1.33544236F,	1.336045138F,	1.336648188F,	1.337251511F,	1.337855105F,	1.338458972F,	1.339063112F,
	1.339667524F,	1.340272209F,	1.340877167F,	1.341482398F,	1.342087903F,	1.34269368F,	1.343299731F,	1.343906056F,
	1.344512654F,	1.345119526F,	1.345726672F,	1.346334092F,	1.346941786F,	1.347549755F,	1.348157998F,	1.348766515F,
	1.349375307F,	1.349984374F,	1.350593716F,	1.351203333F,	1.351813225F,	1.352423392F,	1.353033835F,	1.353644553F,
	1.354255547F,	1.354866817F,	1.355478362F,	1.356090184F,	1.356702282F,	1.357314656F,	1.357927306F,	1.358540233F,
	1.359153437F,	1.359766917F,	1.360380675F,	1.360994709F,	1.361609021F,	1.362223609F,	1.362838476F,	1.363453619F,
	1.364069041F,	1.36468474F,	1.365300717F,	1.365916972F,	1.366533506F,	1.367150317F,	1.367767407F,	1.368384776F,
	1.369002423F,	1.369620349F,	1.370238554F,	1.370857038F,	1.371475801F,	1.372094843F,	1.372714165F,	1.373333766F,
	1.373953647F,	1.374573808F,	1.375194249F,	1.37581497F,	1.376435971F,	1.377057252F,	1.377678814F,	1.378300656F,
	1.378922779F,	1.379545183F,	1.380167867F,	1.380790833F,	1.38141408F,	1.382037608F,	1.382661418F,	1.383285509F,
	1.383909882F,	1.384534537F,	1.385159473F,	1.385784692F,	1.386410193F,	1.387035977F,	1.387662042F,	1.388288391F,
	1.388915022F,	1.389541936F,	1.390169133F,	1.390796613F,	1.391424376F,	1.392052422F,	1.392680752F,	1.393309366F,
	1.393938263F,	1.394567445F,	1.39519691F,	1.395826659F,	1.396456693F,	1.397087011F,	1.397717613F,	1.398348501F,
	1.398979673F,	1.399611129F,	1.400242871F,	1.400874898F,	1.40150721F,	1.402139808F,	1.402772691F,	1.40340586F,
	1.404039315F,	1.404673055F,	1.405307082F,	1.405941395F,	1.406575994F,	1.407210879F,	1.407846051F,	1.40848151F,
	1.409117256F,	1.409753289F,	1.410389608F,	1.411026215F,	1.411663109F,	1.412300291F,	1.41293776F,	1.413575517F,
	1.414213562F,	1.414851895F,	1.415490516F,	1.416129426F,	1.416768623F,	1.417408109F,	1.418047884F,	1.418687948F,
	1.4193283F,		1.419968942F,	1.420609873F,	1.421251093F,	1.421892602F,	1.422534401F,	1.42317649F,	1.423818868F,
	1.424461537F,	1.425104495F,	1.425747744F,	1.426391283F,	1.427035113F,	1.427679233F,	1.428323644F,	1.428968346F,
	1.429613338F,	1.430258622F,	1.430904197F,	1.431550064F,	1.432196222F,	1.432842672F,	1.433489413F,	1.434136447F,
	1.434783772F,	1.43543139F,	1.4360793F,		1.436727502F,	1.437375997F,	1.438024785F,	1.438673866F,	1.439323239F,
	1.439972906F,	1.440622866F,	1.441273119F,	1.441923666F,	1.442574506F,	1.44322564F,	1.443877069F,	1.444528791F,
	1.445180807F,	1.445833118F,	1.446485723F,	1.447138622F,	1.447791816F,	1.448445306F,	1.44909909F,	1.449753169F,
	1.450407543F,	1.451062213F,	1.451717178F,	1.452372439F,	1.453027996F,	1.453683848F,	1.454339997F,	1.454996442F,
	1.455653183F,	1.45631022F,	1.456967554F,	1.457625185F,	1.458283113F,	1.458941337F,	1.459599859F,	1.460258678F,
	1.460917794F,	1.461577208F,	1.462236919F,	1.462896929F,	1.463557236F,	1.464217841F,	1.464878744F,	1.465539946F,
	1.466201446F,	1.466863245F,	1.467525342F,	1.468187738F,	1.468850433F,	1.469513428F,	1.470176721F,	1.470840314F,
	1.471504207F,	1.472168399F,	1.472832891F,	1.473497683F,	1.474162775F,	1.474828167F,	1.475493859F,	1.476159852F,
	1.476826146F,	1.47749274F,	1.478159635F,	1.478826832F,	1.479494329F,	1.480162128F,	1.480830228F,	1.481498629F,
	1.482167333F,	1.482836338F,	1.483505645F,	1.484175254F,	1.484845166F,	1.48551538F,	1.486185896F,	1.486856715F,
	1.487527837F,	1.488199262F,	1.48887099F,	1.489543021F,	1.490215355F,	1.490887993F,	1.491560934F,	1.492234179F,
	1.492907728F,	1.493581581F,	1.494255739F,	1.4949302F,		1.495604966F,	1.496280037F,	1.496955412F,	1.497631092F,
	1.498307077F,	1.498983367F,	1.499659962F,	1.500336863F,	1.50101407F,	1.501691582F,	1.502369399F,	1.503047523F,
	1.503725953F,	1.504404689F,	1.505083732F,	1.505763081F,	1.506442736F,	1.507122698F,	1.507802968F,	1.508483544F,
	1.509164428F,	1.509845618F,	1.510527117F,	1.511208923F,	1.511891036F,	1.512573458F,	1.513256187F,	1.513939225F,
	1.514622571F,	1.515306226F,	1.515990189F,	1.516674461F,	1.517359041F,	1.518043931F,	1.51872913F,	1.519414638F,
	1.520100455F,	1.520786582F,	1.521473019F,	1.522159765F,	1.522846822F,	1.523534189F,	1.524221866F,	1.524909853F,
	1.525598151F,	1.526286759F,	1.526975679F,	1.527664909F,	1.52835445F,	1.529044303F,	1.529734467F,	1.530424942F,
	1.53111573F,	1.531806829F,	1.53249824F,	1.533189963F,	1.533881998F,	1.534574345F,	1.535267006F,	1.535959978F,
	1.536653264F,	1.537346862F,	1.538040774F,	1.538734999F,	1.539429537F,	1.540124388F,	1.540819553F,	1.541515032F,
	1.542210825F,	1.542906932F,	1.543603354F,	1.544300089F,	1.544997139F,	1.545694504F,	1.546392183F,	1.547090177F,
	1.547788487F,	1.548487111F,	1.549186051F,	1.549885307F,	1.550584878F,	1.551284764F,	1.551984967F,	1.552685486F,
	1.553386321F,	1.554087472F,	1.55478894F,	1.555490724F,	1.556192825F,	1.556895243F,	1.557597978F,	1.558301031F,
	1.5590044F,		1.559708087F,	1.560412092F,	1.561116415F,	1.561821055F,	1.562526013F,	1.56323129F,	1.563936885F,
	1.564642798F,	1.56534903F,	1.566055581F,	1.566762451F,	1.56746964F,	1.568177148F,	1.568884975F,	1.569593122F,
	1.570301589F,	1.571010375F,	1.571719481F,	1.572428908F,	1.573138654F,	1.573848721F,	1.574559108F,	1.575269816F,
	1.575980845F,	1.576692195F,	1.577403866F,	1.578115858F,	1.578828171F,	1.579540806F,	1.580253763F,	1.580967041F,
	1.581680641F,	1.582394564F,	1.583108809F,	1.583823376F,	1.584538265F,	1.585253478F,	1.585969013F,	1.586684871F,
	1.587401052F,	1.588117556F,	1.588834384F,	1.589551536F,	1.590269011F,	1.59098681F,	1.591704933F,	1.59242338F,
	1.593142151F,	1.593861247F,	1.594580668F,	1.595300413F,	1.596020483F,	1.596740878F,	1.597461598F,	1.598182643F,
	1.598904014F,	1.599625711F,	1.600347733F,	1.601070081F,	1.601792756F,	1.602515756F,	1.603239083F,	1.603962736F,
	1.604686716F,	1.605411023F,	1.606135656F,	1.606860617F,	1.607585905F,	1.60831152F,	1.609037463F,	1.609763734F,
	1.610490332F,	1.611217258F,	1.611944513F,	1.612672095F,	1.613400006F,	1.614128246F,	1.614856814F,	1.615585711F,
	1.616314938F,	1.617044493F,	1.617774377F,	1.618504592F,	1.619235135F,	1.619966009F,	1.620697212F,	1.621428745F,
	1.622160609F,	1.622892803F,	1.623625327F,	1.624358182F,	1.625091368F,	1.625824885F,	1.626558732F,	1.627292911F,
	1.628027422F,	1.628762264F,	1.629497437F,	1.630232943F,	1.63096878F,	1.63170495F,	1.632441452F,	1.633178286F,
	1.633915453F,	1.634652953F,	1.635390785F,	1.636128951F,	1.63686745F,	1.637606282F,	1.638345447F,	1.639084947F,
	1.63982478F,	1.640564947F,	1.641305448F,	1.642046283F,	1.642787453F,	1.643528957F,	1.644270796F,	1.645012969F,
	1.645755478F,	1.646498322F,	1.647241501F,	1.647985016F,	1.648728866F,	1.649473052F,	1.650217574F,	1.650962432F,
	1.651707626F,	1.652453156F,	1.653199024F,	1.653945227F,	1.654691768F,	1.655438645F,	1.65618586F,	1.656933412F,
	1.657681301F,	1.658429528F,	1.659178092F,	1.659926995F,	1.660676235F,	1.661425814F,	1.662175731F,	1.662925986F,
	1.66367658F,	1.664427513F,	1.665178785F,	1.665930396F,	1.666682346F,	1.667434636F,	1.668187265F,	1.668940234F,
	1.669693543F,	1.670447192F,	1.671201181F,	1.67195551F,	1.67271018F,	1.67346519F,	1.674220541F,	1.674976233F,
	1.675732267F,	1.676488641F,	1.677245357F,	1.678002414F,	1.678759814F,	1.679517555F,	1.680275638F,	1.681034063F,
	1.681792831F,	1.682551941F,	1.683311393F,	1.684071189F,	1.684831327F,	1.685591809F,	1.686352633F,	1.687113802F,
	1.687875313F,	1.688637169F,	1.689399368F,	1.690161912F,	1.690924799F,	1.691688031F,	1.692451608F,	1.693215529F,
	1.693979795F,	1.694744405F,	1.695509361F,	1.696274663F,	1.697040309F,	1.697806302F,	1.69857264F,	1.699339324F,
	1.700106354F,	1.70087373F,	1.701641453F,	1.702409522F,	1.703177937F,	1.7039467F,		1.70471581F,	1.705485266F,
	1.706255071F,	1.707025222F,	1.707795721F,	1.708566568F,	1.709337763F,	1.710109306F,	1.710881197F,	1.711653437F,
	1.712426025F,	1.713198962F,	1.713972248F,	1.714745883F,	1.715519867F,	1.7162942F,		1.717068883F,	1.717843916F,
	1.718619298F,	1.719395031F,	1.720171113F,	1.720947546F,	1.721724329F,	1.722501463F,	1.723278948F,	1.724056783F,
	1.72483497F,	1.725613508F,	1.726392397F,	1.727171638F,	1.727951231F,	1.728731176F,	1.729511472F,	1.730292121F,
	1.731073122F,	1.731854476F,	1.732636182F,	1.733418241F,	1.734200653F,	1.734983419F,	1.735766537F,	1.73655001F,
	1.737333835F,	1.738118015F,	1.738902548F,	1.739687436F,	1.740472678F,	1.741258274F,	1.742044225F,	1.742830531F,
	1.743617191F,	1.744404207F,	1.745191578F,	1.745979304F,	1.746767386F,	1.747555824F,	1.748344617F,	1.749133767F,
	1.749923272F,	1.750713134F,	1.751503353F,	1.752293928F,	1.75308486F,	1.753876149F,	1.754667796F,	1.755459799F,
	1.75625216F,	1.757044879F,	1.757837956F,	1.75863139F,	1.759425183F,	1.760219334F,	1.761013843F,	1.761808711F,
	1.762603938F,	1.763399524F,	1.764195468F,	1.764991772F,	1.765788436F,	1.766585459F,	1.767382842F,	1.768180585F,
	1.768978687F,	1.769777151F,	1.770575974F,	1.771375158F,	1.772174703F,	1.772974609F,	1.773774875F,	1.774575503F,
	1.775376493F,	1.776177843F,	1.776979556F,	1.77778163F,	1.778584067F,	1.779386865F,	1.780190027F,	1.78099355F,
	1.781797436F,	1.782601685F,	1.783406297F,	1.784211273F,	1.785016611F,	1.785822313F,	1.786628379F,	1.787434809F,
	1.788241602F,	1.78904876F,	1.789856282F,	1.790664169F,	1.79147242F,	1.792281036F,	1.793090017F,	1.793899363F,
	1.794709075F,	1.795519152F,	1.796329595F,	1.797140403F,	1.797951578F,	1.798763118F,	1.799575025F,	1.800387298F,
	1.801199938F,	1.802012945F,	1.802826319F,	1.80364006F,	1.804454168F,	1.805268643F,	1.806083487F,	1.806898698F,
	1.807714277F,	1.808530224F,	1.809346539F,	1.810163223F,	1.810980276F,	1.811797697F,	1.812615487F,	1.813433647F,
	1.814252176F,	1.815071074F,	1.815890341F,	1.816709979F,	1.817529987F,	1.818350364F,	1.819171112F,	1.819992231F,
	1.82081372F,	1.821635579F,	1.82245781F,	1.823280412F,	1.824103385F,	1.82492673F,	1.825750446F,	1.826574535F,
	1.827398995F,	1.828223827F,	1.829049031F,	1.829874608F,	1.830700558F,	1.831526881F,	1.832353576F,	1.833180645F,
	1.834008086F,	1.834835902F,	1.835664091F,	1.836492654F,	1.83732159F,	1.838150901F,	1.838980587F,	1.839810647F,
	1.840641081F,	1.84147189F,	1.842303075F,	1.843134634F,	1.843966569F,	1.844798879F,	1.845631565F,	1.846464627F,
	1.847298065F,	1.848131879F,	1.84896607F,	1.849800636F,	1.85063558F,	1.851470901F,	1.852306598F,	1.853142673F,
	1.853979125F,	1.854815955F,	1.855653162F,	1.856490747F,	1.857328711F,	1.858167052F,	1.859005772F,	1.859844871F,
	1.860684348F,	1.861524205F,	1.86236444F,	1.863205054F,	1.864046048F,	1.864887422F,	1.865729175F,	1.866571309F,
	1.867413822F,	1.868256716F,	1.86909999F,	1.869943645F,	1.87078768F,	1.871632097F,	1.872476895F,	1.873322074F,
	1.874167634F,	1.875013576F,	1.8758599F,		1.876706606F,	1.877553694F,	1.878401165F,	1.879249018F,	1.880097254F,
	1.880945872F,	1.881794874F,	1.882644259F,	1.883494027F,	1.884344179F,	1.885194715F,	1.886045634F,	1.886896938F,
	1.887748625F,	1.888600698F,	1.889453154F,	1.890305996F,	1.891159223F,	1.892012834F,	1.892866831F,	1.893721214F,
	1.894575982F,	1.895431135F,	1.896286675F,	1.897142601F,	1.897998914F,	1.898855613F,	1.899712698F,	1.900570171F,
	1.90142803F,	1.902286277F,	1.903144911F,	1.904003932F,	1.904863342F,	1.905723139F,	1.906583324F,	1.907443898F,
	1.90830486F,	1.909166211F,	1.91002795F,	1.910890079F,	1.911752596F,	1.912615503F,	1.913478799F,	1.914342486F,
	1.915206561F,	1.916071027F,	1.916935883F,	1.91780113F,	1.918666767F,	1.919532795F,	1.920399213F,	1.921266023F,
	1.922133224F,	1.923000816F,	1.9238688F,		1.924737176F,	1.925605944F,	1.926475103F,	1.927344656F,	1.9282146F,
	1.929084938F,	1.929955668F,	1.930826791F,	1.931698307F,	1.932570217F,	1.93344252F,	1.934315217F,	1.935188308F,
	1.936061793F,	1.936935673F,	1.937809947F,	1.938684615F,	1.939559678F,	1.940435136F,	1.94131099F,	1.942187238F,
	1.943063882F,	1.943940922F,	1.944818358F,	1.94569619F,	1.946574418F,	1.947453042F,	1.948332063F,	1.949211481F,
	1.950091295F,	1.950971507F,	1.951852116F,	1.952733123F,	1.953614527F,	1.954496329F,	1.955378529F,	1.956261128F,
	1.957144124F,	1.958027519F,	1.958911313F,	1.959795506F,	1.960680098F,	1.961565089F,	1.96245048F,	1.963336271F,
	1.964222461F,	1.965109051F,	1.965996041F,	1.966883432F,	1.967771223F,	1.968659415F,	1.969548008F,	1.970437002F,
	1.971326397F,	1.972216194F,	1.973106392F,	1.973996992F,	1.974887994F,	1.975779399F,	1.976671205F,	1.977563415F,
	1.978456026F,	1.979349041F,	1.980242459F,	1.98113628F,	1.982030505F,	1.982925133F,	1.983820165F,	1.984715601F,
	1.985611441F,	1.986507685F,	1.987404335F,	1.988301388F,	1.989198847F,	1.990096711F,	1.99099498F,	1.991893654F,
	1.992792734F,	1.99369222F,	1.994592112F,	1.99549241F,	1.996393115F,	1.997294226F,	1.998195744F,	1.999097668F
};

struct Environment {
	EFXEAXREVERBPROPERTIES prop;
	ALuint effect;
};

// Enviromental Presets.
static Environment Sound_Enviroments[] =
{
	{EFX_REVERB_PRESET_GENERIC, 0},
	{EFX_REVERB_PRESET_PADDEDCELL, 0},
	{EFX_REVERB_PRESET_ROOM, 0},
	{EFX_REVERB_PRESET_BATHROOM, 0},
	{EFX_REVERB_PRESET_LIVINGROOM, 0},
	{EFX_REVERB_PRESET_STONEROOM, 0},
	{EFX_REVERB_PRESET_AUDITORIUM, 0},
	{EFX_REVERB_PRESET_CONCERTHALL, 0},
	{EFX_REVERB_PRESET_CAVE, 0},
	{EFX_REVERB_PRESET_ARENA, 0},
	{EFX_REVERB_PRESET_HANGAR, 0},
	{EFX_REVERB_PRESET_CARPETEDHALLWAY, 0},
	{EFX_REVERB_PRESET_HALLWAY, 0},
	{EFX_REVERB_PRESET_STONECORRIDOR, 0},
	{EFX_REVERB_PRESET_ALLEY, 0},
	{EFX_REVERB_PRESET_FOREST, 0},
	{EFX_REVERB_PRESET_CITY, 0},
	{EFX_REVERB_PRESET_MOUNTAINS, 0},
	{EFX_REVERB_PRESET_QUARRY, 0},
	{EFX_REVERB_PRESET_PLAIN, 0},
	{EFX_REVERB_PRESET_PARKINGLOT, 0},
	{EFX_REVERB_PRESET_SEWERPIPE, 0},
	{EFX_REVERB_PRESET_UNDERWATER, 0},
	{EFX_REVERB_PRESET_DRUGGED, 0},
	{EFX_REVERB_PRESET_DIZZY, 0},
	{EFX_REVERB_PRESET_PSYCHOTIC, 0}
	// TODO - add "plain"
};

const int kMaxReverbPresets = sizeof(Sound_Enviroments) / sizeof(Sound_Enviroments[0]);

LPALGENAUXILIARYEFFECTSLOTS    alGenAuxiliaryEffectSlots;
LPALDELETEEFFECTS              alDeleteEffects;
LPALAUXILIARYEFFECTSLOTI       alAuxiliaryEffectSloti;
LPALDELETEAUXILIARYEFFECTSLOTS alDeleteAuxiliaryEffectSlots;

ALuint effectSlot;

static int SoundMaxHW = 128;
extern int GlobalFrameCounter;

static int PlatChangeSoundPan(int activeIndex, int pan);
static int ToneToFrequency(int currentFrequency, int currentPitch, int newPitch);

extern DISPLAYBLOCK *Player;
extern VIEWDESCRIPTORBLOCK *Global_VDB_Ptr;
extern int DopplerShiftIsOn;
extern int SoundSwitchedOn;

#define ALFAILED(function) 

//#define FAILED(hr) (((HRESULT)(hr)) < 0)

ALenum AlCheckError()
{
	ALenum error = alGetError();
	switch (error)
	{
		case AL_NO_ERROR:
			// fine.
			break;
		case AL_INVALID_NAME:
			Con_PrintError("OpenAL Error - AL_INVALID_NAME");
			break;
		case AL_INVALID_ENUM:
			Con_PrintError("OpenAL Error - AL_INVALID_ENUM");
			break;
		case AL_INVALID_OPERATION:
			Con_PrintError("OpenAL Error - AL_INVALID_OPERATION");
			break;
		case AL_OUT_OF_MEMORY:
			Con_PrintError("OpenAL Error - AL_OUT_OF_MEMORY");
			break;
	}
	return error;
}

/* ----------------------------------------------------------------------------
  int PlatStartSoundSys
  return 0 on failure, 1 for success
  ----------------------------------------------------------------------------*/
int PlatStartSoundSys()
{
	Con_PrintMessage("Starting to initialise OpenAL");

	uint32_t sampleRate = Config_GetInt("[Audio]", "SampleRate", 44100);

	// Set the globals.
	SoundConfig.reverb_changed	= true;
	SoundConfig.reverb_mix		= 0.0f;
	SoundConfig.env_index		= 1000;

	device = alcOpenDevice(NULL);
	if (device == NULL) {
		Con_PrintError("alcOpenDevice failed for OpenAL");
		PlatEndSoundSys();
		return 0;
	}

	context = alcCreateContext(device, NULL);
	if (context == NULL) {
		Con_PrintError("alcCreateContext failed for OpenAL");
		PlatEndSoundSys();
		return 0;
	}

	alcMakeContextCurrent(context);
	AlCheckError();

	// check for EAX
	if (alcIsExtensionPresent(device, "ALC_EXT_EFX")) {
		Con_PrintMessage("ALC_EXT_EFX is supported for OpenAL");
		efxAvailable = true;
	}
	else {
		Con_PrintMessage("ALC_EXT_EFX not supported for OpenAL");
		efxAvailable = false;
	}

	if (efxAvailable)
	{
		LPALGENEFFECTS alGenEffects = (LPALGENEFFECTS)alGetProcAddress("alGenEffects");
		LPALEFFECTI alEffecti = (LPALEFFECTI)alGetProcAddress("alEffecti");
		LPALEFFECTF alEffectf = (LPALEFFECTF)alGetProcAddress("alEffectf");
		LPALEFFECTFV alEffectfv = (LPALEFFECTFV)alGetProcAddress("alEffectfv");
		alGenAuxiliaryEffectSlots = (LPALGENAUXILIARYEFFECTSLOTS)alGetProcAddress("alGenAuxiliaryEffectSlots");
		alAuxiliaryEffectSloti = (LPALAUXILIARYEFFECTSLOTI)alGetProcAddress("alAuxiliaryEffectSloti");
		alDeleteEffects = (LPALDELETEEFFECTS)alGetProcAddress("alDeleteEffects");
		alDeleteAuxiliaryEffectSlots = (LPALDELETEAUXILIARYEFFECTSLOTS)alGetProcAddress("alDeleteAuxiliaryEffectSlots");

		for (int i = 0; i < kMaxReverbPresets; i++) 
		{
			ALuint effect;
			alGenEffects(1, &effect);

			EFXEAXREVERBPROPERTIES reverb = Sound_Enviroments[i].prop;

			if (alGetEnumValue("AL_EFFECT_EAXREVERB") != 0)
			{
				alEffecti(effect, AL_EFFECT_TYPE, AL_EFFECT_EAXREVERB);

				alEffectf(effect,  AL_EAXREVERB_DENSITY,			reverb.flDensity);
				alEffectf(effect,  AL_EAXREVERB_DIFFUSION,			reverb.flDiffusion);
				alEffectf(effect,  AL_EAXREVERB_GAIN,				reverb.flGain);
				alEffectf(effect,  AL_EAXREVERB_GAINHF,				reverb.flGainHF);
				alEffectf(effect,  AL_EAXREVERB_GAINLF,				reverb.flGainLF);
				alEffectf(effect,  AL_EAXREVERB_DECAY_TIME,			reverb.flDecayTime);
				alEffectf(effect,  AL_EAXREVERB_DECAY_HFRATIO,		reverb.flDecayHFRatio);
				alEffectf(effect,  AL_EAXREVERB_DECAY_LFRATIO,		reverb.flDecayLFRatio);
				alEffectf(effect,  AL_EAXREVERB_REFLECTIONS_GAIN,	reverb.flReflectionsGain);
				alEffectf(effect,  AL_EAXREVERB_REFLECTIONS_DELAY,	reverb.flReflectionsDelay);
				alEffectfv(effect, AL_EAXREVERB_REFLECTIONS_PAN,	reverb.flReflectionsPan);
				alEffectf(effect,  AL_EAXREVERB_LATE_REVERB_GAIN,	reverb.flLateReverbGain);
				alEffectf(effect,  AL_EAXREVERB_LATE_REVERB_DELAY,	reverb.flLateReverbDelay);
				alEffectfv(effect, AL_EAXREVERB_LATE_REVERB_PAN,	reverb.flLateReverbPan);
				alEffectf(effect,  AL_EAXREVERB_ECHO_TIME,			reverb.flEchoTime);
				alEffectf(effect,  AL_EAXREVERB_ECHO_DEPTH,			reverb.flEchoDepth);
				alEffectf(effect,  AL_EAXREVERB_MODULATION_TIME,	reverb.flModulationTime);
				alEffectf(effect,  AL_EAXREVERB_MODULATION_DEPTH,	reverb.flModulationDepth);
				alEffectf(effect,  AL_EAXREVERB_AIR_ABSORPTION_GAINHF, reverb.flAirAbsorptionGainHF);
				alEffectf(effect,  AL_EAXREVERB_HFREFERENCE,		reverb.flHFReference);
				alEffectf(effect,  AL_EAXREVERB_LFREFERENCE,		reverb.flLFReference);
				alEffectf(effect,  AL_EAXREVERB_ROOM_ROLLOFF_FACTOR, reverb.flRoomRolloffFactor);
				alEffecti(effect,  AL_EAXREVERB_DECAY_HFLIMIT,		reverb.iDecayHFLimit);
			}
			else
			{
				// No EAX Reverb. Set the standard reverb effect type then load the available reverb properties.
				alEffecti(effect, AL_EFFECT_TYPE, AL_EFFECT_REVERB);

				alEffectf(effect, AL_REVERB_DENSITY,			reverb.flDensity);
				alEffectf(effect, AL_REVERB_DIFFUSION,			reverb.flDiffusion);
				alEffectf(effect, AL_REVERB_GAIN,				reverb.flGain);
				alEffectf(effect, AL_REVERB_GAINHF,				reverb.flGainHF);
				alEffectf(effect, AL_REVERB_DECAY_TIME,			reverb.flDecayTime);
				alEffectf(effect, AL_REVERB_DECAY_HFRATIO,		reverb.flDecayHFRatio);
				alEffectf(effect, AL_REVERB_REFLECTIONS_GAIN,	reverb.flReflectionsGain);
				alEffectf(effect, AL_REVERB_REFLECTIONS_DELAY,	reverb.flReflectionsDelay);
				alEffectf(effect, AL_REVERB_LATE_REVERB_GAIN,	reverb.flLateReverbGain);
				alEffectf(effect, AL_REVERB_LATE_REVERB_DELAY,	reverb.flLateReverbDelay);
				alEffectf(effect, AL_REVERB_AIR_ABSORPTION_GAINHF, reverb.flAirAbsorptionGainHF);
				alEffectf(effect, AL_REVERB_ROOM_ROLLOFF_FACTOR, reverb.flRoomRolloffFactor);
				alEffecti(effect, AL_REVERB_DECAY_HFLIMIT,		reverb.iDecayHFLimit);
			}

			Sound_Enviroments[i].effect = effect;
			Sound_Enviroments[i].prop = reverb;
		}

		alGenAuxiliaryEffectSlots(1, &effectSlot);
	}

	// try create up to 255 sources
	for (size_t i = 0; i < 255; i++) {
		sndSource newSource;
		alGenSources(1, &newSource._alSource);
		if (alGetError() != AL_NO_ERROR) {
			break;
		}

		// set default properties
		alSourcef(newSource._alSource, AL_PITCH, 1.0f);
		alSourcef(newSource._alSource, AL_GAIN,  1.0f);
		alSourcef(newSource._alSource, AL_ROLLOFF_FACTOR,    0.01f);
		alSourcef(newSource._alSource, AL_REFERENCE_DISTANCE, 1.0f);

		sourceList.push_back(newSource);
	}

	playerPosition.x = 0.0f;
	playerPosition.y = 0.0f;
	playerPosition.z = 0.0f;

	playerVelocity.x = 0.0f;
	playerVelocity.y = 0.0f;
	playerVelocity.z = 0.0f;

	playerOrientation.lookAt.x = 0.0f;
	playerOrientation.lookAt.y = 0.0f;
	playerOrientation.lookAt.z = -1.0f;
	playerOrientation.up.x = 0.0f;
	playerOrientation.up.y = -1.0f;
	playerOrientation.up.z = 0.0f;

	alListenerf(AL_GAIN, 1.0f);
	alListenerfv(AL_POSITION,    (ALfloat*)&playerPosition);
	alListenerfv(AL_VELOCITY,    (ALfloat*)&playerVelocity);
	alListenerfv(AL_ORIENTATION, (ALfloat*)&playerOrientation);
	
	alDistanceModel(AL_NONE);
/*
	ALCint nummono, numstereo;
	alcGetIntegerv(device, ALC_MONO_SOURCES, 1, &nummono);
	alcGetIntegerv(device, ALC_STEREO_SOURCES, 1, &numstereo);
*/
	Con_PrintMessage("Initialised OpenAL successfully");

	soundEnabled = true;

	return 1;
}

void PlatEndSoundSys()
{
	// lets check all sounds are stopped and released here (important to handle alt+f4 close)
	SoundSys_RemoveAll();

	// release sources
	for (size_t i = 0; i < sourceList.size(); i++) {
		if (efxAvailable) {
			alSource3i(sourceList[i]._alSource, AL_AUXILIARY_SEND_FILTER, AL_EFFECTSLOT_NULL, 0, AL_FILTER_NULL);
		}
		alDeleteSources(1, &sourceList[i]._alSource);
	}

	if (efxAvailable) {
		alAuxiliaryEffectSloti(effectSlot, AL_EFFECTSLOT_EFFECT, AL_EFFECT_NULL);
		alDeleteAuxiliaryEffectSlots(1, &effectSlot);

		for (int i = 0; i < kMaxReverbPresets; i++) {
			alDeleteEffects(1, &Sound_Enviroments[i].effect);
		}
	}

	alcMakeContextCurrent(NULL);
	alcDestroyContext(context);
	alcCloseDevice(device);

	Con_PrintMessage("Uninitialised OpenAL successfully");
}

void SetBufferCurrentPosition(ACTIVESOUNDSAMPLE *activeSound, int position)
{
	alSourcei(activeSound->source->_alSource, AL_BYTE_OFFSET, position);
}

void GetBufferCurrentPosition(ACTIVESOUNDSAMPLE *activeSound, int *position)
{
	alGetSourcei(activeSound->source->_alSource, AL_BYTE_OFFSET, position);
}

bool CheckSoundBufferIsValid(ACTIVESOUNDSAMPLE *activeSound)
{
	if (activeSound->source) {
		return true;
	}
	else {
		return false;
	}
}

int PlatChangeGlobalVolume(int volume)
{
	if (!soundEnabled) {
		return 1; // keep quiet about it?
	}

	LOCALASSERT((volume >= VOLUME_MIN) && (volume <= VOLUME_MAX));

	// set the volume
	alListenerf(AL_GAIN, vol_to_gain_table[volume]);

	return 1;
}

static sndSource* FindFreeSource()
{
	for (size_t i = 0; i < sourceList.size(); i++) {
		if (sourceList[i]._isFree) {
			sourceList[i]._isFree = false;
			return &sourceList[i];
		}
	}
	return NULL;
}

int PlatPlaySound(int activeIndex)
{
	// check bounds of active sound index
	LOCALASSERT ((activeIndex >= 0) || (activeIndex < SOUND_MAXACTIVE));
	
	SOUNDINDEX gameIndex = ActiveSounds[activeIndex].soundIndex;
	LOCALASSERT ((gameIndex >= 0) && (gameIndex < SID_MAXIMUM));
	LOCALASSERT (GameSounds[gameIndex].loaded);

	// try get a free source to use
	ActiveSounds[activeIndex].source = FindFreeSource();
	if (!ActiveSounds[activeIndex].source) {
		Con_PrintDebugMessage("No free sources available");
		return SOUND_PLATFORMERROR;
	}

	// duplicate the game sound buffer
	ActiveSounds[activeIndex].audioBuffer = GameSounds[gameIndex].audioBuffer;
	ActiveSounds[activeIndex].buffer = GameSounds[gameIndex].buffer;

	// may need to initialise pitch before playing
//	if (ActiveSounds[activeIndex].pitch != GameSounds[gameIndex].pitch)
	{
		int ok = PlatChangeSoundPitch(activeIndex, ActiveSounds[activeIndex].pitch);
		if (ok == SOUND_PLATFORMERROR)
		{
			PlatStopSound (activeIndex);
			return SOUND_PLATFORMERROR;
		}
	}

	// Initialise volume before playing
	if (ActiveSounds[activeIndex].threedee)
	{
		// set distance at which attenuation starts
		if (ActiveSounds[activeIndex].threedeedata.inner_range == 0) {
			ActiveSounds[activeIndex].threedeedata.inner_range = static_cast<int>(1.0f); //DS3D_DEFAULTMINDISTANCE;
		}

		// 3D sounds always need initialising
		if (PlatDo3dSound(activeIndex) == SOUND_PLATFORMERROR)
		{
			PlatStopSound(activeIndex);
			return SOUND_PLATFORMERROR;
		}
	}
	else // 2D
	{
		int newVolume = ActiveSounds[activeIndex].volume;
		newVolume = (newVolume * VOLUME_PLAT2DSCALE) >> 7;
		ActiveSounds[activeIndex].volume = newVolume;

		ALfloat zero[3] = { 0.0f, 0.0f, 0.0f };
		alSourcei (ActiveSounds[activeIndex].source->_alSource, AL_SOURCE_RELATIVE, AL_TRUE);
		alSourcefv(ActiveSounds[activeIndex].source->_alSource, AL_POSITION, zero);
		alSourcefv(ActiveSounds[activeIndex].source->_alSource, AL_VELOCITY, zero);

		if (PlatChangeSoundVolume(activeIndex, ActiveSounds[activeIndex].volume) == SOUND_PLATFORMERROR)
		{
			PlatStopSound(activeIndex);
			return SOUND_PLATFORMERROR;
		}
	}

	/*

	typedef enum 
	{
		DSPROPERTY_EAXBUFFER_ALL,           // all reverb buffer properties
		DSPROPERTY_EAXBUFFER_REVERBMIX      // the wet source amount
	} DSPROPERTY_EAXBUFFER_REVERBPROPERTY;

	*/

	// handle reverb
	if (!ActiveSounds[activeIndex].reverb_off)
	{
		// DSPROPERTY_EAXBUFFER_REVERBMIX - SoundConfig.reverb_mix
	}
	else
	{
		// DSPROPERTY_EAXBUFFER_REVERBMIX - 0
	}

	// player the buffer
	if (!ActiveSounds[activeIndex].paused)
	{
		alSourceStop(ActiveSounds[activeIndex].source->_alSource);
		AlCheckError();

		alSourcei(ActiveSounds[activeIndex].source->_alSource, AL_BUFFER, ActiveSounds[activeIndex].buffer);
		AlCheckError();

		alSourcei(ActiveSounds[activeIndex].source->_alSource, AL_LOOPING, ActiveSounds[activeIndex].loop ? AL_TRUE : AL_FALSE);
		AlCheckError();

		// reverb
		if (efxAvailable && !ActiveSounds[activeIndex].reverb_off) {
			alSource3i(ActiveSounds[activeIndex].source->_alSource, AL_AUXILIARY_SEND_FILTER, effectSlot, 0, AL_FILTER_NULL);
			AlCheckError();
		}

		alSourcePlay(ActiveSounds[activeIndex].source->_alSource);
		AlCheckError();
	}
	return 1;
}

void PlatStopSound(int activeIndex)
{
	if (!soundEnabled) {
		return;
	}

	if (!ActiveSounds[activeIndex].paused)
	{
		alSourceStop(ActiveSounds[activeIndex].source->_alSource);
		AlCheckError();
	}

	ActiveSounds[activeIndex].is3D = false;
	ActiveSounds[activeIndex].audioBuffer = NULL; // GameSounds has the original reference to this memory
	ActiveSounds[activeIndex].buffer = 0;

	if (efxAvailable) {
		alSource3i(ActiveSounds[activeIndex].source->_alSource, AL_AUXILIARY_SEND_FILTER, AL_EFFECTSLOT_NULL, 0, AL_FILTER_NULL);
	}

	alSourcei(ActiveSounds[activeIndex].source->_alSource, AL_BUFFER, NULL);

	// set source to free and invalidate local handle
	ActiveSounds[activeIndex].source->_isFree = true;
	ActiveSounds[activeIndex].source = NULL;
}

int PlatChangeSoundVolume(int activeIndex, int volume)
{
	if (ActiveSounds[activeIndex].source) {
		alSourcef(ActiveSounds[activeIndex].source->_alSource, AL_GAIN, vol_to_gain_table[volume]);
		AlCheckError();
	}
	return 1;
}

int PlatChangeSoundPitch(int activeIndex, int pitch)
{
	LOCALASSERT((pitch >= PITCH_MIN) && (pitch <= PITCH_MAX));

	// calculate new frequency from base pitch for game sound (NB don't need to scale pitch values...)
	SOUNDINDEX gameSoundIndex = ActiveSounds[activeIndex].soundIndex;

	float frequency;

	if (pitch == PITCH_DEFAULTPLAT) {
		frequency = (float)GameSounds[gameSoundIndex].dsFrequency;
	}
	else {
		frequency = (float)ToneToFrequency(GameSounds[gameSoundIndex].dsFrequency, GameSounds[gameSoundIndex].pitch, pitch);
	}

	frequency = frequency / GameSounds[gameSoundIndex].dsFrequency;
	
	alSourcef(ActiveSounds[activeIndex].source->_alSource, AL_PITCH, frequency);

	ActiveSounds[activeIndex].pitch = pitch;

	return 1;
}

int PlatSoundHasStopped(int activeIndex)
{
	ALint value;
	alGetSourceiv(ActiveSounds[activeIndex].source->_alSource, AL_SOURCE_STATE, &value);
	AlCheckError();

	if ((value != AL_PLAYING) && (value != AL_PAUSED)) {
		return 1;
	}

	return 0;
}

int PlatDo3dSound(int activeIndex)
{
	VECTORCH relativePosn;

	if (!soundEnabled) {
		return 0;
	}

	// find the distance of the sound
	relativePosn.vx = ActiveSounds[activeIndex].threedeedata.position.vx - Global_VDB_Ptr->VDB_World.vx;
	relativePosn.vy = ActiveSounds[activeIndex].threedeedata.position.vy - Global_VDB_Ptr->VDB_World.vy;
	relativePosn.vz = ActiveSounds[activeIndex].threedeedata.position.vz - Global_VDB_Ptr->VDB_World.vz;

	int distance = Magnitude(&relativePosn);
	int newVolume = 0;

	// Deal with paused looping sounds.
	if (ActiveSounds[activeIndex].paused)
	{
		if (distance < (ActiveSounds[activeIndex].threedeedata.outer_range + SOUND_DEACTIVATERANGE))
		{
			alSourcei(ActiveSounds[activeIndex].source->_alSource, AL_LOOPING, ActiveSounds[activeIndex].loop ? AL_TRUE : AL_FALSE);
			alSourcePlay(ActiveSounds[activeIndex].source->_alSource);
			newVolume = 0;
			ActiveSounds[activeIndex].paused = 0;
		}
		else {
			return 1;
		}
	}

	if (distance < ActiveSounds[activeIndex].threedeedata.inner_range)
	{
		newVolume = ActiveSounds[activeIndex].volume;
	}
	else
	{
		if (distance < ActiveSounds[activeIndex].threedeedata.outer_range)
		{
			// Use proper 3D, but our own attenuation.
			float in_to_dis_to_out = static_cast<float>(ActiveSounds[activeIndex].threedeedata.outer_range - distance);
			float in_to_out = static_cast<float>(ActiveSounds[activeIndex].threedeedata.outer_range - ActiveSounds[activeIndex].threedeedata.inner_range);

			if (in_to_out > 0.0f) {
				newVolume = (int)((float)ActiveSounds[activeIndex].volume * (in_to_dis_to_out / in_to_out));
			}
			else {
				newVolume = 0;
			}
		}
		else
		{
			newVolume = 0;

			// Deal with looping sounds.
			if ((distance < (ActiveSounds[activeIndex].threedeedata.outer_range + SOUND_DEACTIVATERANGE)) &&
				ActiveSounds[activeIndex].loop)
			{
				alSourcePause(ActiveSounds[activeIndex].source->_alSource);
				ActiveSounds[activeIndex].paused = 1;
			}
		}
	}

	if (newVolume > VOLUME_MAX) newVolume = VOLUME_MAX;
	if (newVolume < VOLUME_MIN) newVolume = VOLUME_MIN;

	if (PlatChangeSoundVolume(activeIndex, newVolume) == SOUND_PLATFORMERROR) {
		return SOUND_PLATFORMERROR;
	}

	// Now deal with the panning issues.
	if (distance < ActiveSounds[activeIndex].threedeedata.outer_range)
	{
		ALvector position;
		position.x = (ALfloat)relativePosn.vx;
		position.y = (ALfloat)relativePosn.vy;
		position.z = -(ALfloat)relativePosn.vz;

		alSourcei (ActiveSounds[activeIndex].source->_alSource, AL_SOURCE_RELATIVE, AL_FALSE);
		alSourcefv(ActiveSounds[activeIndex].source->_alSource, AL_POSITION, (ALfloat*)&position);

		// TODO - velocity stuff?
	}
	return 1;
}

void PlatUnloadGameSound(SOUNDINDEX index)
{
	if ((index < 0) || (index >= SID_MAXIMUM)) {
		return; // no such sound
	}

	for (int i = 0; i < SOUND_MAXACTIVE; i++) {
		if (ActiveSounds[i].soundIndex == index) {
//			alSourcei(ActiveSounds[i].source->_alSource, AL_BUFFER, 0);
			PlatStopSound(i);
		}
	}

	alDeleteBuffers(1, &GameSounds[index].buffer);

	delete[] GameSounds[index].audioBuffer;
	GameSounds[index].audioBuffer = NULL;

	GameSounds[index].dsFrequency = 0;
	GameSounds[index].loaded = 0;

	GameSounds[index].wavName.clear();
}

static int PlatChangeSoundPan(int activeIndex, int pan)
{
	return 1;
}

unsigned int PlatMaxHWSounds()
{
	return SoundMaxHW;
}

void InitialiseBaseFrequency(SOUNDINDEX soundNum)
{
	int frequency = 0;

	// validate the loaded pitch
	if (GameSounds[soundNum].pitch > PITCH_MAXPLAT) GameSounds[soundNum].pitch = PITCH_MAXPLAT;
	if (GameSounds[soundNum].pitch < PITCH_MINPLAT) GameSounds[soundNum].pitch = PITCH_MINPLAT;
	
	// get the frequency
	frequency = GameSounds[soundNum].dsFrequency;
	
	// if the pitch is default, just return at this point
	if (GameSounds[soundNum].pitch == PITCH_DEFAULTPLAT) {
		return;
	}

	frequency = ToneToFrequency(GameSounds[soundNum].dsFrequency, PITCH_DEFAULTPLAT, GameSounds[soundNum].pitch);
	
	// We can't actually set the pitch/frequency here as we don't get assigned a source until play time.
	// PlatPlaySound() will always force a pitch change as a result to ensure this gets set correctly

	GameSounds[soundNum].dsFrequency = frequency;
}

int ReturnInvalidWAV()
{
	Con_PrintError("Invalid WAV file");
	return 0;
}

inline ALenum GetALFormat(uint16_t bitsPerSample, uint16_t nChannels)
{
	ALenum alFormat = 0;

	if (bitsPerSample == 8)
	{
		if (nChannels == 1) {
			alFormat = AL_FORMAT_MONO8;
		}
		else if (nChannels == 2) {
			alFormat = AL_FORMAT_STEREO8;
		}
	}
	else if (bitsPerSample == 16)
	{
		if (nChannels == 1) {
			alFormat = AL_FORMAT_MONO16;
		}
		else if (nChannels == 2) {
			alFormat = AL_FORMAT_STEREO16;
		}
	}
	else {
		assert(1==0);
	}
	return alFormat;
}

int LoadWavFile(int soundNum, const std::string &fileName)
{
	// try open the file
	FileStream fStream;
	fStream.Open(fileName, FileStream::FileRead);

	if (!fStream.IsGood())
	{
		Con_PrintError("Can't open WAV file");
		return 0;
	}

	// Read the WAV RIFF header
	uint32_t chunkID = fStream.GetUint32BE();
	if (chunkID != 'RIFF') {
		return ReturnInvalidWAV();
	}

	uint32_t chunkSize = fStream.GetUint32LE();
	uint32_t format    = fStream.GetUint32BE();
	if (format != 'WAVE') {
		return ReturnInvalidWAV();
	}

	uint32_t subChunkID = fStream.GetUint32BE();
	if (subChunkID != 'fmt ') {
		return ReturnInvalidWAV();
	}

	uint32_t subChunkSize = fStream.GetUint32LE();

	uint16_t wFormatTag      = fStream.GetUint16LE();
	uint16_t nChannels       = fStream.GetUint16LE();
	uint32_t nSamplesPerSec  = fStream.GetUint32LE();
	uint32_t nAvgBytesPerSec = fStream.GetUint32LE();
	uint16_t nBlockAlign     = fStream.GetUint16LE();
	uint16_t wBitsPerSample  = fStream.GetUint16LE();

	// if not PCM
	if (subChunkSize == 18) {
		uint16_t cbSize = fStream.GetUint16LE();
		assert(cbSize == 0);
	}
	else if (subChunkSize != 16) {
		Con_PrintError("Only PCM WAV files are supported");
		return 0;
	}

	while (1)
	{
		subChunkID = fStream.GetUint32BE();

		if (subChunkID != 'data') 
		{
			subChunkSize = fStream.GetUint32LE();
			fStream.Seek(subChunkSize, FileStream::SeekCurrent);
		}
		else {
			break;
		}
	}

	uint32_t nAudioBytes = fStream.GetUint32LE();

	ALenum alFormat = GetALFormat(wBitsPerSample, nChannels);

	GameSounds[soundNum].audioBuffer = new uint8_t[nAudioBytes];

	// Read sound data from file to buffer
	uint32_t nBytesRead = fStream.ReadBytes(GameSounds[soundNum].audioBuffer, nAudioBytes);
	if (nBytesRead != nAudioBytes)
	{
		LOCALASSERT(1==0);
		delete[] GameSounds[soundNum].audioBuffer;
		GameSounds[soundNum].audioBuffer = NULL;
		return 0;
	}

	// create and store audio buffer
	alGenBuffers(1, &GameSounds[soundNum].buffer);
	alBufferData(GameSounds[soundNum].buffer, alFormat, GameSounds[soundNum].audioBuffer, nAudioBytes, nSamplesPerSec);

	size_t lastSlash = fileName.find_last_of('/');
	if (lastSlash != fileName.npos) // if we found '/'
	{
		lastSlash++;
	}
	else {
		lastSlash = 0;
	}

	GameSounds[soundNum].wavName = fileName.substr(lastSlash);

	// need to save this here for later use
	GameSounds[soundNum].dsFrequency = nSamplesPerSec;
	GameSounds[soundNum].length = DIV_FIXED(nAudioBytes, nAvgBytesPerSec);

	return 1;
}

int ExtractWavFile(int soundNum, FileStream &fStream)
{
	int64_t startOffset = 0;
	uint32_t totalChunkSize = 0;

	// read in the wav file name until we hit the null terminator
	while (fStream.PeekByte() != '\0')
	{
		GameSounds[soundNum].wavName += fStream.GetByte();
	}

	// skip string null terminator
	fStream.GetByte();

	// Read the RIFF chunk header
	uint32_t chunkID = fStream.GetUint32BE();
	if (chunkID != 'RIFF') {
		return ReturnInvalidWAV();
	}

	uint32_t chunkSize = fStream.GetUint32LE();

	totalChunkSize = chunkSize;
	startOffset = fStream.GetCurrentPos();

	uint32_t format = fStream.GetUint32BE();
	if (format != 'WAVE') {
		return ReturnInvalidWAV();
	}

	uint32_t subChunkID = fStream.GetUint32BE();
	if (subChunkID != 'fmt ') {
		return ReturnInvalidWAV();
	}

	uint32_t subChunkSize = fStream.GetUint32LE();

	uint16_t wFormatTag      = fStream.GetUint16LE();
	uint16_t nChannels       = fStream.GetUint16LE();
	uint32_t nSamplesPerSec  = fStream.GetUint32LE();
	uint32_t nAvgBytesPerSec = fStream.GetUint32LE();
	uint16_t nBlockAlign     = fStream.GetUint16LE();
	uint16_t wBitsPerSample  = fStream.GetUint16LE();

	// if not PCM
	if (subChunkSize == 18) {
		uint16_t cbSize = fStream.GetUint16LE();
		assert(cbSize == 0);
	}
	else if (subChunkSize != 16) {
		Con_PrintError("Only PCM WAV files are supported");
		return 0;
	}

	while (1)
	{
		subChunkID = fStream.GetUint32BE();

		if (subChunkID != 'data') 
		{
			subChunkSize = fStream.GetUint32LE();
			fStream.Seek(subChunkSize, FileStream::SeekCurrent);
		}
		else {
			break;
		}
	}

	uint32_t nAudioBytes = fStream.GetUint32LE();

	ALenum alFormat = GetALFormat(wBitsPerSample, nChannels);

	GameSounds[soundNum].audioBuffer = new uint8_t[nAudioBytes];

	// Read sound data from file to buffer
	uint32_t nBytesRead = fStream.ReadBytes(GameSounds[soundNum].audioBuffer, nAudioBytes);

	if (nBytesRead != nAudioBytes)
	{
		LOCALASSERT(1==0);
		delete[] GameSounds[soundNum].audioBuffer;
		GameSounds[soundNum].audioBuffer = NULL;
		return 0;
	}

	// create and store audio buffer
	alGenBuffers(1, &GameSounds[soundNum].buffer);
	alBufferData(GameSounds[soundNum].buffer, alFormat, GameSounds[soundNum].audioBuffer, nAudioBytes, nSamplesPerSec);

	// need to save this here for later use
	GameSounds[soundNum].dsFrequency = nSamplesPerSec;
	GameSounds[soundNum].length = DIV_FIXED(nAudioBytes, nAvgBytesPerSec);

	fStream.Seek(startOffset + totalChunkSize, FileStream::SeekStart);

	return 1;
}

// TODO - move to common?
static int ToneToFrequency(int currentFrequency, int currentPitch, int newPitch)
{
	if (!soundEnabled) {
		return 0;
	}

	int newFrequency = currentFrequency;

	LOCALASSERT((currentPitch>=PITCH_MINPLAT)&&(currentPitch<=PITCH_MAXPLAT));
	LOCALASSERT((currentFrequency>=FREQUENCY_MINPLAT)&&(currentPitch<=FREQUENCY_MAXPLAT));

	// limit pitch
	if (newPitch > PITCH_MAXPLAT) newPitch = PITCH_MAXPLAT;
	if (newPitch < PITCH_MINPLAT) newPitch = PITCH_MINPLAT;

	if (newPitch>currentPitch)
	{
		// scale up
		int numOctaves, numTones;
		numOctaves = (newPitch-currentPitch)/1536;
		numTones = (newPitch-currentPitch)%1536;

		newFrequency<<=numOctaves;
		if (newFrequency > FREQUENCY_MAXPLAT) newFrequency = FREQUENCY_MAXPLAT;
		
		if (numTones > 0) {
			newFrequency = (int)((float)(newFrequency)*pitch_to_frequency_mult_table[numTones]);
		}

		if (newFrequency > FREQUENCY_MAXPLAT) newFrequency = FREQUENCY_MAXPLAT;
	}
	else
	{
		// scale down
		int numOctaves, numTones;
		numOctaves = (currentPitch-newPitch)/1536;
		numTones = (currentPitch-newPitch)%1536;

		newFrequency>>=numOctaves;
		if (newFrequency < FREQUENCY_MINPLAT) newFrequency = FREQUENCY_MINPLAT;

		if (numTones > 0) {
			newFrequency = (int)((float)(newFrequency)/pitch_to_frequency_mult_table[numTones]);
		}

		if (newFrequency < FREQUENCY_MINPLAT) newFrequency = FREQUENCY_MINPLAT;
	}
	return newFrequency;
}

void PlatUpdatePlayer()
{
	if (!soundEnabled) {
		return;
	}

	// update the listener (ie the player)
	if (Global_VDB_Ptr)
	{
		if ((Global_VDB_Ptr->VDB_World.vx == 0) &&
				(Global_VDB_Ptr->VDB_World.vy == 0) &&
				(Global_VDB_Ptr->VDB_World.vz == 0))
			return;

		// position
		playerPosition.x = 0.0f;
		playerPosition.y = 0.0f;
		playerPosition.z = 0.0f;

		// look-at
		playerLookAt.x = (float)(Global_VDB_Ptr->VDB_Mat.mat13) / 65536.0f;
		playerLookAt.y = (float)(Global_VDB_Ptr->VDB_Mat.mat23) / 65536.0f;
		playerLookAt.z = (float)(Global_VDB_Ptr->VDB_Mat.mat33) / 65536.0f;

		if (AvP.PlayerType != I_Alien) {
			playerOrientation.lookAt.x = playerLookAt.x;
			playerOrientation.lookAt.y = 0.0f;
			playerOrientation.lookAt.z = -playerLookAt.z;

			// up
			playerOrientation.up.x = 0.0f;
			playerOrientation.up.y = 1.0f;
			playerOrientation.up.z = 0.0f;
		}
		else { // Alien
			playerOrientation.lookAt.x = playerLookAt.x;
			playerOrientation.lookAt.y = playerLookAt.y;
			playerOrientation.lookAt.z = -playerLookAt.z;

			// up (negated for OpenAL)
			playerOrientation.up.x = (float)(Global_VDB_Ptr->VDB_Mat.mat12) / 65536.0f;
			playerOrientation.up.y = (float)(Global_VDB_Ptr->VDB_Mat.mat22) / 65536.0f;
			playerOrientation.up.z = -(float)(Global_VDB_Ptr->VDB_Mat.mat32) / 65536.0f;
		}

		if (AvP.PlayerType == I_Alien && DopplerShiftIsOn && NormalFrameTime)
		{
			DYNAMICSBLOCK *dynPtr = Player->ObStrategyBlock->DynPtr;

			float invFrameTime = 100000.0f / (float)NormalFrameTime;

			playerVelocity.x = (float)(dynPtr->Position.vx - dynPtr->PrevPosition.vx) * invFrameTime;
			playerVelocity.y = (float)(dynPtr->Position.vy - dynPtr->PrevPosition.vy) * invFrameTime;
			playerVelocity.z = -(float)(dynPtr->Position.vz - dynPtr->PrevPosition.vz) * invFrameTime;
		}
		else
		{
			playerVelocity.x = 0.0f;
			playerVelocity.y = 0.0f;
			playerVelocity.z = 0.0f;
		}

		// Reverb
		if (efxAvailable && SoundConfig.reverb_changed)
		{
			unsigned int count = SOUND_MAXACTIVE;

			// Go through every sound setting the reverb
			while (count--)
			{
				if (ActiveSounds[count].source)
				{
					if (ActiveSounds[count].reverb_off) {
						alSource3i(ActiveSounds[count].source->_alSource, AL_AUXILIARY_SEND_FILTER, AL_EFFECTSLOT_NULL, 0, AL_FILTER_NULL);	
					}
					else {
						alSource3i(ActiveSounds[count].source->_alSource, AL_AUXILIARY_SEND_FILTER, effectSlot, 0, AL_FILTER_NULL);
					}
				}
			}
			SoundConfig.reverb_changed = false;
		}

		alListenerfv(AL_ORIENTATION, (ALfloat*)&playerOrientation);
		alListenerfv(AL_VELOCITY,    (ALfloat*)&playerVelocity);
		alListenerfv(AL_POSITION,    (ALfloat*)&playerPosition);
	}
}

void PlatSetEnviroment(unsigned int env_index, float reverb_mix)
{
	if (!efxAvailable) {
		return;
	}

	// Set up the enviroment.
	if (SoundConfig.env_index != env_index) {

		// set 
		alAuxiliaryEffectSloti(effectSlot, AL_EFFECTSLOT_EFFECT, Sound_Enviroments[env_index].effect);
		SoundConfig.env_index = env_index;
	}

	if (reverb_mix == SoundConfig.reverb_mix) {
		return;
	}

	if ((reverb_mix < 0.0f) || (reverb_mix > 1.0f))
	{
		db_log3("Using EAX,");
		SoundConfig.reverb_mix = 0.0f; //EAX_REVERBMIX_USEDISTANCE;	
	}
	else
	{
		db_log3("Using reverb_mix,");
		SoundConfig.reverb_mix = reverb_mix;
	}

	SoundConfig.reverb_changed = true;
}

void ResetEaxEnvironment()
{
//	PlatSetEnviroment();
}

int PlatUse3DSoundHW()
{
	// only called by a console command
	return 1;
}

int PlatDontUse3DSoundHW()
{
	// only called by a console command
	return 1;
}

void UpdateSoundFrequencies()
{
	if (!soundEnabled) {
		return;
	}

	if (!SoundSwitchedOn) {
		return;
	}

	for (uint32_t i = 0; i < SOUND_MAXACTIVE; i++)
	{
		int32_t gameIndex = ActiveSounds[i].soundIndex;

		if (gameIndex == SID_NOSOUND) {
			continue;
		}

//		IDirectSoundBuffer_SetFrequency(ActiveSounds[i].dsBufferP,MUL_FIXED(GameSounds[gameIndex].dsFrequency,TimeScale));
		if (ActiveSounds[i].pitch != GameSounds[gameIndex].pitch)
		{
			PlatChangeSoundPitch(i, ActiveSounds[i].pitch);
		}
	}
}

AudioStream::AudioStream()
{
	_source = NULL;
	_bufferSize    = 0;
	_bufferCount   = 0;
	_currentBuffer = 0;
	_nChannels   = 0;
	_rate = 0;
	_bytesPerSample      = 0;
	_totalBytesPlayed    = 0;
	_totalSamplesWritten = 0;
	_isPaused  = false;
	_isPlaying = false;
	_buffers  = NULL;
	_dataBuffers = NULL;
	_format = 0;
	_volume = 0;
}

bool AudioStream::Init(uint32_t nChannels, uint32_t rate, uint32_t bitsPerSample, uint32_t bufferSize, uint32_t nBuffers)
{
	if (!soundEnabled) {
		return false;
	}

	_format = GetALFormat(bitsPerSample, nChannels);

	// allocate space for n AL buffers
	_buffers = new(std::nothrow) ALuint[nBuffers];
	if (NULL == _buffers) {
		Con_PrintError("Out of memory trying to create streaming audio AL buffer(s)");
		return false;
	}

	// allocate space where actual audio data goes
	_dataBuffers = new(std::nothrow) uint8_t[bufferSize * nBuffers];
	if (NULL == _dataBuffers) {
		Con_PrintError("Out of memory trying to create streaming audio data buffer");
		return false;
	}

	// clear OpenAL errors
	alGetError();

	alGenBuffers(nBuffers, _buffers);
	AlCheckError();
	
	_source = FindFreeSource();
	if (!_source) {
		Con_PrintError("No free sources available for streaming audio");
		return false;
	}

	alSourcei (_source->_alSource, AL_LOOPING,         AL_FALSE);
	alSource3f(_source->_alSource, AL_POSITION,        0.0f, 0.0f, 0.0f);
	alSource3f(_source->_alSource, AL_VELOCITY,        0.0f, 0.0f, 0.0f);
	alSource3f(_source->_alSource, AL_DIRECTION,       0.0f, 0.0f, 0.0f);
	alSourcef (_source->_alSource, AL_ROLLOFF_FACTOR,  0.0f);
	alSourcei (_source->_alSource, AL_SOURCE_RELATIVE, AL_TRUE);

	_bytesPerSample = bitsPerSample / 8;
	_nChannels = nChannels;
	_rate = rate;
	_bufferSize  = bufferSize;
	_bufferCount = nBuffers;

	// set this to true for threads to run
	_isPlaying = true;

	for (uint32_t i = 0; i < nBuffers; i++) {
		_freeBufferQueue.push_back(_buffers[i]);
	}

	if (pthread_create(&_playbackThread, NULL, CheckProcessedBuffers, static_cast<void*>(this)) != 0) {
		return false;
	}
	if (pthread_mutex_init(&_bufferMutex, NULL) != 0) {
		return false;
	}

	return true;
}

uint32_t AudioStream::WriteData(uint8_t *audioData, uint32_t size)
{
	assert (audioData);
	assert (size == _bufferSize);

	// clear OpenAL errors
	alGetError();

	if (_freeBufferQueue.size()) {

		pthread_mutex_lock(&_bufferMutex);

		ALuint buffer = _freeBufferQueue.front();
		_freeBufferQueue.pop_front();

		memcpy(&_dataBuffers[_currentBuffer * _bufferSize], audioData, size);

		alBufferData(buffer, _format, &_dataBuffers[_currentBuffer * _bufferSize], size, _rate);
		AlCheckError();

		// queue it
		alSourceQueueBuffers(_source->_alSource, 1, &buffer);
		AlCheckError();

		pthread_mutex_unlock(&_bufferMutex);
	}

	_currentBuffer++;
	_currentBuffer %= _bufferCount;

	// size in bytes divided by bytes per sample divided by the number of channels
	_totalSamplesWritten += ((size / _bytesPerSample) / _nChannels);

	return size;
}

void AudioStream::WaitForFreeBuffer()
{
	while (_freeBufferQueue.size() == 0) {
		Sleep(20);
	}
}

void *CheckProcessedBuffers(void *args)
{
	AudioStream *stream = static_cast<AudioStream*>(args);

	while (stream->_isPlaying)
	{
		if (!stream->_isPaused) {

			alGetError();

			ALint nProcessed;
			alGetSourcei(stream->_source->_alSource, AL_BUFFERS_PROCESSED, &nProcessed);
			AlCheckError();

			if (nProcessed && (stream->_freeBufferQueue.size() < stream->_bufferCount)) {

				pthread_mutex_lock(&stream->_bufferMutex);

				ALuint buffer;
				alSourceUnqueueBuffers(stream->_source->_alSource, 1, &buffer);
				AlCheckError();

				stream->_freeBufferQueue.push_back(buffer);
				stream->_totalBytesPlayed += stream->_bufferSize;

				pthread_mutex_unlock(&stream->_bufferMutex);
			}
			else {
				// wait and try again
				::Sleep(kQuantum);
			}
		}
	}

	return 0;
}

uint32_t AudioStream::GetBufferSize()
{
	return _bufferSize;
}

uint32_t AudioStream::GetNumFreeBuffers()
{
	return _freeBufferQueue.size();
}

uint64_t AudioStream::GetNumSamplesPlayed()
{
	return ((_totalBytesPlayed / _bytesPerSample) / _nChannels);
}

uint64_t AudioStream::GetNumSamplesWritten()
{
	return _totalSamplesWritten;
}

uint32_t AudioStream::GetWritableBufferSize()
{
	return _bufferSize * _freeBufferQueue.size();
}

int32_t AudioStream::SetVolume(uint32_t volume)
{
	alSourcef(_source->_alSource, AL_GAIN, vol_to_gain_table[volume]);
	return 1;
}

uint32_t AudioStream::GetVolume()
{
	return _volume;
}

int32_t AudioStream::SetPan(uint32_t pan)
{
	// todo: implement this function
	return AUDIOSTREAM_OK;
}

int32_t AudioStream::Stop()
{
	_isPlaying = false;

	alSourceStop(_source->_alSource);

	return AUDIOSTREAM_OK;
}

int32_t AudioStream::Play()
{
	alSourcePlay(_source->_alSource);
	AlCheckError();
	_isPaused = false;

	return AUDIOSTREAM_OK;
}

AudioStream::~AudioStream()
{
	Stop();

	pthread_join(_playbackThread, NULL);
	pthread_mutex_destroy(&_bufferMutex);

	alSourcei(_source->_alSource, AL_BUFFER, NULL);

	_source->_isFree = true;
	_source = NULL;

	alDeleteBuffers(_bufferCount, _buffers);

	// clear the new-ed memory
	delete[] _buffers;
	delete[] _dataBuffers;
}

#endif // #ifdef USE_OPENAL
